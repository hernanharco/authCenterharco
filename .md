üìù Prompt Definitivo: Arquitectura Modular con Supabase & HttpOnly Cookies
Objetivo: Implementar un sistema de autenticaci√≥n completo y seguro utilizando un stack Node.js/Express y Next.js, gestionando la autenticaci√≥n de usuarios y base de datos con Supabase, y la sesi√≥n mediante HttpOnly Cookies. El proyecto debe seguir el principio de Separaci√≥n de Responsabilidades a nivel de m√≥dulo/clase.

I. Estructura de Proyecto
El proyecto se dividir√° en dos directorios principales (backend y frontend).

II. Backend (Node.js/Express) - Modular
El backend se enfocar√° √∫nicamente en servir la API y proteger las rutas, delegando las verificaciones de autenticaci√≥n a un servicio dedicado.

Herramientas Clave: express, jsonwebtoken, dotenv, cookie-parser.

M√≥dulos de Responsabilidad:

server.js: Solo configuraci√≥n inicial, middlewares globales y montaje de rutas.

./src/routes/authRoutes.js: Define la ruta de Logout y cualquier ruta de intercambio de tokens.

./src/services/authService.js: Contiene la l√≥gica de verificaci√≥n del JWT con Supabase (ej. llamando a supabase.auth.getUser()) y la gesti√≥n de cookies (establecer/eliminar).

./src/middleware/authMiddleware.js: Contiene la funci√≥n que extrae la authToken de la cookie y llama a authService.verifyToken().

III. Frontend (Next.js) - Modular
El frontend se centrar√° en la UI y la interacci√≥n directa con el cliente de Supabase.

Herramientas Clave: Cliente de Supabase (@supabase/supabase-js).

M√≥dulos de Responsabilidad:

./utils/supabase.js: √önica inicializaci√≥n del cliente Supabase.

./utils/api.js: Utilidad de fetch con credentials: 'include' para todas las llamadas al backend Express.

./components/AuthForm.js: L√≥gica de login y registro, usando supabase.auth.signInWithPassword() y supabase.auth.signUp(). No debe manejar cookies ni JWT.

./pages/dashboard.js: Maneja el ciclo de vida (llamada a la ruta protegida) y la redirecci√≥n en caso de error 401/403.

./components/providers/AuthProvider.js: (Opcional pero recomendado) Contexto de React para gestionar el estado de "autenticado" en el cliente.

IV. Flujo Cr√≠tico de Autenticaci√≥n
Login (Frontend): El usuario usa AuthForm.js para llamar a Supabase.

Respuesta Supabase: Supabase genera un JWT.

Intercambio de Token (CR√çTICO): Inmediatamente despu√©s del login exitoso, el Frontend debe enviar el JWT (devuelto por Supabase) a un endpoint de Express (ej., POST /auth/set-cookie).

Establecer Cookie (Backend): El authRoutes de Express recibe el JWT y lo establece como la HttpOnly Cookie (authToken).

Rutas Protegidas (Posterior): Todas las solicitudes subsiguientes incluyen la authToken. El authMiddleware extrae el token y el authService lo verifica con Supabase antes de dar acceso.

üìÅ Estructura de Carpetas Final con Responsabilidades
Esta estructura a√≠sla las preocupaciones (UI, Enrutamiento, Servicios de Auth, Middlewares) en m√≥dulos espec√≠ficos.

mi-proyecto-auth-modular/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ node_modules/
‚îÇ   ‚îú‚îÄ‚îÄ .env                       # SUPABASE_URL, SUPABASE_KEY, JWT_SECRET
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ authService.js     # L√≥gica de verificaci√≥n con Supabase y manejo de cookies
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ authMiddleware.js  # Extrae cookie y llama a authService.verify
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ authRoutes.js      # Rutas /auth/set-cookie, /auth/logout
‚îÇ   ‚îú‚îÄ‚îÄ server.js                  # Inicializaci√≥n Express y montaje de rutas
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îÇ
‚îî‚îÄ‚îÄ frontend/
    ‚îú‚îÄ‚îÄ node_modules/
    ‚îú‚îÄ‚îÄ pages/
    ‚îÇ   ‚îú‚îÄ‚îÄ login.js               # Usa AuthForm.js y maneja la redirecci√≥n
    ‚îÇ   ‚îî‚îÄ‚îÄ dashboard.js           # P√°gina Protegida
    ‚îú‚îÄ‚îÄ components/
    ‚îÇ   ‚îî‚îÄ‚îÄ AuthForm.js            # L√≥gica de Login/Registro con cliente Supabase
    ‚îú‚îÄ‚îÄ utils/
    ‚îÇ   ‚îú‚îÄ‚îÄ api.js                 # Cliente Fetch con credentials: 'include'
    ‚îÇ   ‚îî‚îÄ‚îÄ supabase.js            # Inicializaci√≥n del cliente Supabase
    ‚îú‚îÄ‚îÄ .env.local                 # Claves p√∫blicas de Supabase
    ‚îî‚îÄ‚îÄ package.json

___________

# üõ†Ô∏è Fase 1: Backend (Node.js/Express con Supabase)

Nos centraremos en la carpeta backend/.

## Paso 1: Configuraci√≥n Inicial
### 1. Crea la estructura de carpetas:
```
mkdir backend
cd backend
mkdir src
mkdir "src/services", "src/middleware", "src/routes"
npm init -y
```
### 2. Instala las dependencias:
```
pnpm install express jsonwebtoken dotenv cookie-parser @supabase/supabase-js body-parser
```
### 3. Crea el archivo .env:
```
# Claves de Supabase (las obtienes de tu proyecto Supabase -> Settings -> API)
SUPABASE_URL="https://[YOUR_PROJECT_REF].supabase.co"
SUPABASE_KEY="[YOUR_SUPABASE_SERVICE_ROLE_KEY]"

# Esta clave es solo para firmar el JWT que Supabase emite.
# NO la uses en el frontend. La obtenemos de Supabase -> Project Settings -> API -> JWT Secret.
SUPABASE_JWT_SECRET="[YOUR_SUPABASE_JWT_SECRET]" 

# Puerto del servidor
PORT=3000
```
_______


## Paso 2: Servicio de Autenticaci√≥n (./src/services/authService.js)

Este m√≥dulo se encarga de toda la interacci√≥n con Supabase y la gesti√≥n de las HttpOnly Cookies, siguiendo el principio de Responsabilidad √önica.
```
// ./src/services/authService.js

require('dotenv').config();
const { createClient } = require('@supabase/supabase-js');
const jwt = require('jsonwebtoken');

// 1. Inicializaci√≥n de Supabase con clave de SERVICIO
// Usamos la Service Role Key para tener acceso de alto nivel para verificar tokens.
const supabase = createClient(
    process.env.SUPABASE_URL,
    process.env.SUPABASE_KEY
);

// Clave Secreta para verificar los tokens emitidos por Supabase
const SUPABASE_JWT_SECRET = process.env.SUPABASE_JWT_SECRET;

// Tiempo de expiraci√≥n de la cookie (1 hora en ms, debe coincidir con el token de Supabase)
const COOKIE_MAX_AGE = 60 * 60 * 1000; 

/**
 * Verifica si un JWT es v√°lido y obtiene los datos del usuario.
 * @param {string} token - El JWT de Supabase.
 * @returns {object} Los datos del payload del token si es v√°lido.
 */
async function verifySupabaseToken(token) {
    if (!token) {
        throw new Error("No se proporcion√≥ token.");
    }
    
    try {
        // Usamos jsonwebtoken para verificar la firma del token con la clave secreta de Supabase.
        const decoded = jwt.verify(token, SUPABASE_JWT_SECRET);
        
        // Opcional: Podr√≠as hacer una verificaci√≥n adicional llamando a Supabase aqu√≠ 
        // para asegurar que el usuario a√∫n existe, pero verificar la firma ya es muy fuerte.
        
        return decoded;
    } catch (error) {
        // Token inv√°lido o expirado
        throw new Error("Token inv√°lido o expirado.");
    }
}

/**
 * Establece el token como una HttpOnly Cookie en la respuesta.
 * @param {object} res - Objeto de respuesta de Express.
 * @param {string} token - El JWT a establecer.
 */
function setAuthCookie(res, token) {
    res.cookie('authToken', token, {
        httpOnly: true,
        // En producci√≥n, debe ser 'true'. Aqu√≠ lo ajustamos seg√∫n el entorno si es necesario.
        secure: process.env.NODE_ENV === 'production', 
        sameSite: 'strict',
        maxAge: COOKIE_MAX_AGE,
    });
}

/**
 * Elimina la HttpOnly Cookie de la respuesta.
 * @param {object} res - Objeto de respuesta de Express.
 */
function clearAuthCookie(res) {
    res.cookie('authToken', '', {
        httpOnly: true,
        expires: new Date(0), // Expira inmediatamente
        sameSite: 'strict',
    });
}

module.exports = {
    verifySupabaseToken,
    setAuthCookie,
    clearAuthCookie,
    supabase // Exportamos el cliente Supabase para otras interacciones si es necesario
};
```
__________

## Paso 3: Middleware de Autenticaci√≥n (./src/middleware/authMiddleware.js)

Este m√≥dulo se encarga de extraer el token y usar el servicio para verificarlo.
```
// ./src/middleware/authMiddleware.js

const authService = require('../services/authService');

/**
 * Middleware para proteger rutas.
 * 1. Extrae el JWT de la HttpOnly Cookie.
 * 2. Verifica la validez del token usando authService.
 * 3. Adjunta los datos del usuario a req.user si es v√°lido.
 */
async function authenticateToken(req, res, next) {
    // 1. Obtener el token de las cookies
    const token = req.cookies.authToken; 

    if (!token) {
        return res.status(401).json({ message: 'Acceso denegado. No se proporcion√≥ token de sesi√≥n authMiddleware.js.' });
    }

    try {
        // 2. Verificar el token usando el servicio
        const userData = await authService.verifySupabaseToken(token);

        // 3. Adjuntar datos del usuario (el payload decodificado)
        req.user = userData;
        
        // Continuar con la ruta
        next(); 
    } catch (error) {
        // Token inv√°lido o expirado
        console.error('Error de verificaci√≥n de token:', error.message);
        authService.clearAuthCookie(res); // Limpia la cookie por seguridad si falla
        return res.status(403).json({ message: 'Sesi√≥n expirada o token inv√°lido. Por favor, inicie sesi√≥n de nuevo.' });
    }
}

module.exports = {
    authenticateToken
};
```
_____

## Paso 4: Rutas de Autenticaci√≥n (./src/routes/authRoutes.js)

Aqu√≠ definimos los endpoints que interact√∫an con el servicio y el middleware.
```
// ./src/routes/authRoutes.js

const express = require("express");
const router = express.Router();
const authService = require("../services/authService");
const { authenticateToken } = require("../middleware/authMiddleware");

// 1. RUTA DE INTERCAMBIO DE TOKEN (CR√çTICA)
// El frontend nos enviar√° el JWT que Supabase le dio.
// Nosotros lo establecemos como una HttpOnly Cookie.
router.post("/set-cookie", async (req, res) => {
  const { token } = req.body;

  if (!token) {
    return res
      .status(400)
      .json({ message: "Token requerido para establecer la cookie." });
  }

  try {
    // Opcional pero recomendado: verificar el token antes de establecerlo
    await authService.verifySupabaseToken(token);

    // Establecer la HttpOnly Cookie
    authService.setAuthCookie(res, token);

    res.json({ message: "Cookie de sesi√≥n establecida correctamente authRoutes.js." });
  } catch (error) {
    res
      .status(401)
      .json({ message: "Token inv√°lido o error al establecer la cookie." });
  }
});

// 2. RUTA DE LOGOUT
router.post("/logout", async (req, res) => {
  // 1. Limpiar la cookie en la respuesta
  authService.clearAuthCookie(res);

  // 2. Opcional: Llama a la funci√≥n de sign out de Supabase si fuera necesario
  //    (aunque la eliminaci√≥n de la cookie y la expiraci√≥n del token son suficientes)
  // await authService.supabase.auth.signOut();

  res.json({ message: "Sesi√≥n cerrada exitosamente." });
});

// 3. RUTA PROTEGIDA (ejemplo)
router.get("/perfil", authenticateToken, (req, res) => {
  // 1. Acceso Seguro al Rol usando Encadenamiento Opcional (?.):
  // El payload de Supabase NO tiene 'role' en el nivel ra√≠z.
  // Buscamos 'user_role' (o 'role') dentro de app_metadata de forma segura.
  const userRole = req.user.app_metadata?.user_role || "default_user";

  // 2. Acceso Seguro a Propiedades Ra√≠z:
  // Aseguramos que 'sub' (ID) y 'email' existen antes de usarlos.
  const userId = req.user?.sub;
  const userEmail = req.user?.email;

  // Si tu c√≥digo ten√≠a esta estructura original, el error estaba en la l√≠nea 53:
  /*
    const userRole = req.user.app_metadata 
                     ? (req.user.app_metadata.role || 'default_user') 
                     : 'default_user'; // Ocurre el error si 'app_metadata' es undefined
    */

  // --- Respuesta Final (L√≠nea 53 corregida) ---
  res.json({
    message: "¬°Acceso Concedido a la informaci√≥n privada!",
    userData: {
      id: userId,
      email: userEmail,
      role: userRole,
      // Si el error de 'role' persiste, temporalmente usa fullPayload
    },
    // Temporalmente, incluye el payload completo para que veas la estructura real
    // fullPayload: req.user
  });
});

module.exports = router;
```
________
## Paso 5: Servidor Principal (server.js)

Ensamblamos todas las partes.
```
// ./server.js

require('dotenv').config(); 
const express = require('express');
const bodyParser = require('body-parser');
const cookieParser = require('cookie-parser');
const authRoutes = require('./src/routes/authRoutes');

const app = express();
const port = process.env.PORT || 3000;

// Configuraci√≥n de Middlewares
app.use(bodyParser.json());
app.use(cookieParser());

// Configuraci√≥n de CORS (CR√çTICO para peticiones entre frontend y backend)
// En desarrollo, permitimos al frontend acceder. AJUSTA ESTO A TU DOMINIO REAL EN PROD.
app.use((req, res, next) => {
    // URL de tu frontend Next.js
    res.header('Access-Control-Allow-Origin', 'http://localhost:3001'); 
    res.header('Access-Control-Allow-Credentials', 'true');
    res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    res.header('Access-Control-Allow-Methods', 'GET, POST');
    next();
});


// Montar Rutas
app.use('/auth', authRoutes);
app.use('/api', authRoutes); // Tambi√©n montamos el perfil en /api

// Ruta de prueba
app.get('/', (req, res) => {
    res.send('Servidor Express de Autenticaci√≥n funcionando.');
});

// Iniciar el Servidor
app.listen(port, () => {
    console.log(`Backend de Auth escuchando en http://localhost:${port}`);
    console.log(`¬°Recuerda iniciar el Frontend en http://localhost:3001!`);
});
```
___
# üß™ Pruebas con Postman (Pre-Frontend)
Antes de pasar a Next.js, probaremos la Ruta Protegida y el Intercambio de Token.

Requisitos Previos en Supabase:

1. Aseg√∫rate de tener un usuario registrado en tu proyecto Supabase (puedes registrar uno manualmente en la secci√≥n Authentication).

## Prueba 1: Fallo al Acceder a Ruta Protegida
1. M√©todo: GET

2. URL: http://localhost:3000/api/perfil

3. Headers: Ninguno.

4. Resultado Esperado: Estado 401 Unauthorized.

## Prueba 2: Intercambio de Token (Simulando Login de Frontend)

1. Obt√©n un JWT de Supabase:

- Usa la API de Supabase o la consola para iniciar sesi√≥n. El JWT se te proporcionar√° despu√©s del login.

- Nota: Si usas el cliente de Supabase en un entorno de prueba, el token est√° en session.access_token.

2. M√©todo: POST

3. URL: http://localhost:3000/auth/set-cookie

4. Headers:

- Content-Type: application/json

5. Body (raw JSON): Reemplaza TU_JWT_DE_SUPABASE por el token real.
```
JSON

{
    "token": "TU_JWT_DE_SUPABASE" 
}
```

6. Resultado Esperado: Estado 200 OK. Lo m√°s importante: Postman ahora habr√° guardado la authToken como una cookie.

## Prueba 3: Acceso Exitoso a Ruta Protegida

1. M√©todo: GET

2. URL: http://localhost:3000/api/perfil

3. Headers: Ninguno (Postman adjuntar√° autom√°ticamente la cookie del paso 2).

4. Resultado Esperado: Estado 200 OK y un JSON que muestra userData con la informaci√≥n del usuario.

Una vez que estas tres pruebas sean exitosas, el backend estar√° listo para interactuar con Next.js.
